# C++ Embedded & Real-time Systems Example
# çµ„ã¿è¾¼ã¿ãƒ»ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚·ã‚¹ãƒ†ãƒ å‘ã‘æœ€é©åŒ–
# RAM/ROMç¯€ç´„ã€RTTI/ä¾‹å¤–ç„¡åŠ¹åŒ–ã€æ±ºå®šè«–çš„å‹•ä½œ

name: C++ Embedded & Real-time CI/CD

on:
  push:
    branches: [main, develop, embedded/*]
  pull_request:
  release:
    types: [created]

jobs:
  # çµ„ã¿è¾¼ã¿ãƒ“ãƒ«ãƒ‰ï¼ˆã‚µã‚¤ã‚ºæœ€é©åŒ–ï¼‰
  build-embedded:
    uses: tomoya-cicd/github-actions-workflows/.github/workflows/c-cpp-cicd.yml@main
    
    with:
      # è¨€èªžè¨­å®š
      language: 'cpp'
      cpp-standard: 'c++17'  # çµ„ã¿è¾¼ã¿ã§ã‚‚ãƒ¢ãƒ€ãƒ³C++
      
      # ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©
      compiler: 'clang'  # LLVMãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§ã‚µã‚¤ã‚ºæœ€é©åŒ–
      
      # ãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ 
      build-system: 'cmake'
      cmake-options: |
        -DCMAKE_BUILD_TYPE=MinSizeRel
        -DENABLE_RTTI=OFF
        -DENABLE_EXCEPTIONS=OFF
        -DENABLE_STATIC_LINKING=ON
        -DCMAKE_CXX_FLAGS="-fno-rtti -fno-exceptions -ffunction-sections -fdata-sections"
        -DCMAKE_EXE_LINKER_FLAGS="-Wl,--gc-sections"
        -DTARGET_EMBEDDED=ON
      
      # æœ€é©åŒ–ãƒ¬ãƒ™ãƒ«
      optimization-level: 'Os'  # ã‚µã‚¤ã‚ºæœ€é©åŒ–
      
      # ãƒ†ã‚¹ãƒˆï¼ˆãƒ›ã‚¹ãƒˆç’°å¢ƒã§ã®ã¿å®Ÿè¡Œï¼‰
      run-tests: true
      test-command: 'ctest --output-on-failure'
      
      # é™çš„è§£æžï¼ˆçµ„ã¿è¾¼ã¿ã§ã¯é‡è¦ï¼‰
      run-static-analysis: true
      run-valgrind: true  # ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡º
      
      # ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
      # build-targets: 'linux-arm64,linux-armv7'
      
      # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
      generate-docs: false
      
      # ãƒ©ãƒ³ãƒŠãƒ¼
      runs-on: 'self-hosted'  # Mac Studio
  
  # ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§èƒ½æ¸¬å®š
  realtime-benchmark:
    needs: build-embedded
    runs-on: self-hosted
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: binaries-native
      
      - name: Run real-time benchmarks
        run: |
          echo "## â±ï¸ Real-time Performance Metrics" >> $GITHUB_STEP_SUMMARY
          
          # ãƒã‚¤ãƒŠãƒªã‚µã‚¤ã‚ºæ¸¬å®š
          echo "### Binary Size" >> $GITHUB_STEP_SUMMARY
          ls -lh build/*.elf build/*.bin 2>/dev/null | awk '{print "- "$9": "$5}' >> $GITHUB_STEP_SUMMARY || true
          
          # ã‚¹ã‚¿ãƒƒã‚¯ä½¿ç”¨é‡è§£æž
          if command -v stack-usage-analyzer &> /dev/null; then
            echo "### Stack Usage" >> $GITHUB_STEP_SUMMARY
            stack-usage-analyzer build/*.su >> $GITHUB_STEP_SUMMARY || true
          fi
          
          # å®Ÿè¡Œæ™‚é–“æ¸¬å®š
          if [ -x "build/benchmark" ]; then
            echo "### Execution Time" >> $GITHUB_STEP_SUMMARY
            ./build/benchmark --format=github >> $GITHUB_STEP_SUMMARY
          fi
  
  # ãƒ¡ãƒ¢ãƒªãƒ•ãƒƒãƒˆãƒ—ãƒªãƒ³ãƒˆè§£æž
  memory-analysis:
    needs: build-embedded
    runs-on: self-hosted
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: binaries-native
      
      - name: Analyze memory footprint
        run: |
          echo "## ðŸ’¾ Memory Footprint Analysis" >> $GITHUB_STEP_SUMMARY
          
          # ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºè¡¨ç¤º
          for binary in build/*.elf build/*.out; do
            if [ -f "$binary" ]; then
              echo "### $(basename $binary)" >> $GITHUB_STEP_SUMMARY
              size "$binary" | tail -1 | awk '{printf "- .text: %s bytes\n- . %s bytes\n- .bss: %s bytes\n- **Total**: %s bytes\n", $1, $2, $3, $4}' >> $GITHUB_STEP_SUMMARY
            fi
          done
          
          # RAM/ROMä½¿ç”¨é‡è¨ˆç®—
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Resource Usage" >> $GITHUB_STEP_SUMMARY
          echo "- ROM: .text + .data" >> $GITHUB_STEP_SUMMARY
          echo "- RAM: .data + .bss" >> $GITHUB_STEP_SUMMARY
